


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  ArrayList源码分析 |    Franklin</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 5.2.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Franklin
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="sort">
             分类
             <div class="categories-outer " id="sort-div">
               <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9D%91/">坑</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9D%91/MySQL/">MySQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap/">HashMap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashSet/">HashSet</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Hashtable/">Hashtable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Stack/">Stack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Vector/">Vector</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">计算机网络基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
             </div>
          </li>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Franklin
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">ArrayList源码分析</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Apr 15 2020</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><h4 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="1. 结构分析"></a>1. 结构分析</h4><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre>
<p>ArrayList继承了AbstractList，实现了List，RandomAccess, Cloneable, serializable接口。</p>
<p>下面分析一些接口的作用：</p>
<h5 id="1-1-List接口"><a href="#1-1-List接口" class="headerlink" title="1.1 List接口"></a>1.1 List接口</h5><p>提供了一些对List进行基本操作的方法。</p>
<h5 id="1-2-RandomAccess接口"><a href="#1-2-RandomAccess接口" class="headerlink" title="1.2 RandomAccess接口"></a>1.2 RandomAccess接口</h5><p>实现了RandomAccess接口的用意是表明ArrayList具有快速访问的功能，查询的时间复杂度为O（1）。</p>
<h6 id="1-3-Cloneable接口"><a href="#1-3-Cloneable接口" class="headerlink" title="1.3 Cloneable接口"></a>1.3 Cloneable接口</h6><p>实现了Cloneable接口的用意是表明ArrayList可以进行克隆，该克隆为浅克隆。</p>
<h5 id="1-4-Serializable接口"><a href="#1-4-Serializable接口" class="headerlink" title="1.4 Serializable接口"></a>1.4 Serializable接口</h5><p>实现了Serializable接口的用意是表明ArrayList可以进行序列化和反序列化，可以进行保存和传输。</p>
<h4 id="2-源码变量分析"><a href="#2-源码变量分析" class="headerlink" title="2. 源码变量分析"></a>2. 源码变量分析</h4><pre><code>private static final long serialVersionUID = 8683452581122892189L; //序列化的版本号，是进行反序列化的凭证。

private static final int DEFAULT_CAPACITY = 10; //默认容量

private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;  //用于空实例的共享空数组实例

private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认大小的空实例的共享空数组实例。我们将其与EMPTY_ELEMENTDATA区分开来，以了解在添加第一个元素时应该膨胀多少。

transient Object[] elementData;  //存储ArrayList元素的数组缓冲区。ArrayList的容量是这个数组缓冲区的长度。以数组的形式储存数据。

private int size; //ArrayList的大小，也称作ArrayList的实际容量

/**
* 要分配的数组的最大大小。一些vm在数组中保留一些标题词。
* 试图分配更大的数组可能会导致OutOfMemoryError:请求的数组大小超过VM限制
*/
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</code></pre>
<h4 id="3-源码方法分析"><a href="#3-源码方法分析" class="headerlink" title="3. 源码方法分析"></a>3. 源码方法分析</h4><h5 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h5><pre><code>//构造具有指定初始容量的空列表。
    public ArrayList(int initialCapacity) &#123; 
        if (initialCapacity &gt; 0) &#123;  //判断指定初始容量值是否大于0
            this.elementData = new Object[initialCapacity];  //构造列表
        &#125; else if (initialCapacity == 0) &#123;  //判断指定初始容量是否等于0
            this.elementData = EMPTY_ELEMENTDATA; //把列表引用指定为用于空实例的空数组
        &#125; else &#123; //如果指定初始容量小于0则抛出异常
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        &#125;
    &#125;

    /**
     * 构造一个初始容量为10的空列表。
     */
    public ArrayList() &#123;
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //在这个方法完成时，列表为空数组
    &#125;

    /**
     * 构造一个列表，其中包含指定集合的元素，按集合的迭代器返回元素的顺序排列。
     */
    public ArrayList(Collection&lt;? extends E&gt; c) &#123;
        elementData = c.toArray();
        if ((size = elementData.length) != 0) &#123;
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        &#125; else &#123;
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        &#125;
    &#125;</code></pre>
<p>疑问：明明 <strong>ArrayList( )</strong> 方法创建的是一个空数组为什么说它的初始容量是10呢？</p>
<p>因为在后续对列表进行操作的时候，会对其数组进行判断，如果数组的对象为<strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong> 则会把初始容量设置为10。</p>
<p>总结：ArrayList提供了三个构造方法给我们进行使用，分别是<strong>ArrayList(int initialCapacity)**，</strong>ArrayList( )<strong>，</strong>ArrayList(Collection&lt;? extends E&gt; c)** 。</p>
<h5 id="3-2-核心方法"><a href="#3-2-核心方法" class="headerlink" title="3.2 核心方法"></a>3.2 核心方法</h5><h6 id="3-2-1-源码"><a href="#3-2-1-源码" class="headerlink" title="3.2.1 源码"></a>3.2.1 源码</h6><pre><code>  /**
   * 如果需要增加这个ArrayList实例的容量，以确保它至少可以容纳由最小容量参数指定的元素数量。
   *
   * @param   minCapacity   the desired minimum capacity
   */
  public void ensureCapacity(int minCapacity) &#123;
      int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) //判断列表构建的时候是否有指定初始容量，有为0，没有为10
          // any size if not default element table
          ? 0
          // larger than default for default empty table. It&#39;s already
          // supposed to be at default size.
          : DEFAULT_CAPACITY;

      if (minCapacity &gt; minExpand) &#123; //如果最小容量参数大于初始容量或构建列表的时候有指定初始容量
          ensureExplicitCapacity(minCapacity);
      &#125;
  &#125;

  private void ensureCapacityInternal(int minCapacity) &#123;
      if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //判断列表构建的时候是否没有指定初始初始容量，是则为真
          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //取初始容量和最小容量参数中的最大值
      &#125;

      ensureExplicitCapacity(minCapacity);
  &#125;

  private void ensureExplicitCapacity(int minCapacity) &#123;
      modCount++;

      // overflow-conscious code
      if (minCapacity - elementData.length &gt; 0)  //如果最小容量参数大于列表的容量，执行grow方法
          grow(minCapacity);
  &#125;

  /**
* 要分配的数组的最大大小。一些vm在数组中保留一些标题词。试图分配更大的数组可能会导致OutOfMemoryError:请求的数组大小超过VM限制
   */
  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

  /**
   * 增加容量，以确保它至少可以容纳由最小容量参数指定的元素数量。
   *
   * @param minCapacity the desired minimum capacity
   */
  private void grow(int minCapacity) &#123;
      // overflow-conscious code
      int oldCapacity = elementData.length; //获取数组的长度，即列表的容量
      int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //将新的列表容量设置为旧容量加上旧容量的二分之一
      if (newCapacity - minCapacity &lt; 0) //如果新容量的值小于最小容量参数，则把新容量的值设置为参数的值
          newCapacity = minCapacity;
      if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果新容量大于数组的最大大小
          newCapacity = hugeCapacity(minCapacity);
      // minCapacity is usually close to size, so this is a win:
      elementData = Arrays.copyOf(elementData, newCapacity); //列表容量的大小变为新容量的值
  &#125;

  private static int hugeCapacity(int minCapacity) &#123;
      if (minCapacity &lt; 0) // 参数小于0则抛出异常
          throw new OutOfMemoryError();
      return (minCapacity &gt; MAX_ARRAY_SIZE) ?    //如果参数值大于数组的最大大小，则返回整型的最大长度，否则返回数组的最大大小
          Integer.MAX_VALUE :
          MAX_ARRAY_SIZE;
  &#125;</code></pre>
<h6 id="3-2-2-核心方法逻辑"><a href="#3-2-2-核心方法逻辑" class="headerlink" title="3.2.2 核心方法逻辑"></a>3.2.2 核心方法逻辑</h6><p>1.判断列表的数组类型</p>
<p>2.根据数组类型来赋予初始容量</p>
<p>3.列表的初始容量与参数进行对比，取其中的最大值</p>
<p>4.将新容量设置为旧容量的值+旧容量的值的一半</p>
<p>5.将新容量的值与参数进行对比，取其中最大值</p>
<p>6.若参数最大则继续将其与数组的最大值做对比，取其中最大值</p>
<p>7.若还是参数最大，则新容量设置为整型基本数据类型的最大长度</p>
<p>8.返回新容量的列表</p>
<h5 id="3-3-常用方法"><a href="#3-3-常用方法" class="headerlink" title="3.3 常用方法"></a>3.3 常用方法</h5><h6 id="3-3-1-trimToSize"><a href="#3-3-1-trimToSize" class="headerlink" title="3.3.1 trimToSize( )"></a>3.3.1 trimToSize( )</h6><pre><code> /**
 * 将这个ArrayList实例的容量调整为列表的当前大小。可以使用此操作最小化ArrayList实例的存储。
 */
public void trimToSize() &#123;
    modCount++;
    if (size &lt; elementData.length) &#123; //如果列表的实际容量小于数组的长度也就是列表的最大容量
    //判断实际容量是否为0，是0则设置为空数组，不为0则把最大容量设置为实际容量
        elementData = (size == 0)  
          ? EMPTY_ELEMENTDATA
          : Arrays.copyOf(elementData, size);
    &#125;
&#125;</code></pre>
<h6 id="3-3-2-size"><a href="#3-3-2-size" class="headerlink" title="3.3.2 size( )"></a>3.3.2 size( )</h6><pre><code>//获取列表的实际容量
    public int size() &#123; 
        return size;
    &#125;</code></pre>
<h6 id="3-3-3-isEmpty"><a href="#3-3-3-isEmpty" class="headerlink" title="3.3.3 isEmpty( )"></a>3.3.3 isEmpty( )</h6><pre><code>//根据列表的实际容量来判断列表是否为空
    public boolean isEmpty() &#123; 
        return size == 0;
    &#125;</code></pre>
<h6 id="3-3-4-contains-Object-o"><a href="#3-3-4-contains-Object-o" class="headerlink" title="3.3.4 contains(Object o)"></a>3.3.4 contains(Object o)</h6><pre><code>//判断是否含有指定的元素
    public boolean contains(Object o) &#123; 
    //查找指定的元素,找到则有，反之无
        return indexOf(o) &gt;= 0; 
    &#125;</code></pre>
<h6 id="3-3-5-indexOf-Object-o"><a href="#3-3-5-indexOf-Object-o" class="headerlink" title="3.3.5 indexOf(Object o )"></a>3.3.5 indexOf(Object o )</h6><pre><code>//从数组头部开始查找指定的元素并返回元素下标
    public int indexOf(Object o) &#123; 
        //如果该元素为null
        if (o == null) &#123; 
            //对数组逐一遍历
            for (int i = 0; i &lt; size; i++) 
                //null没有equals方法，所以用==，并且分开进行判断并遍历
                if (elementData[i]==null)  
                    return i;  //返回该元素的下标
        &#125; else &#123; //如果该元素不为null
            for (int i = 0; i &lt; size; i++) //对数组逐一遍历
                if (o.equals(elementData[i]))
                    return i;  //返回该元素的下标
        &#125;
        return -1;  //没有找到返回-1
    &#125;</code></pre>
<h6 id="3-3-6-lastIndexOf-Object-o"><a href="#3-3-6-lastIndexOf-Object-o" class="headerlink" title="3.3.6 lastIndexOf(Object o)"></a>3.3.6 lastIndexOf(Object o)</h6><pre><code>//从数组尾部开始查找指定元素并返回元素下标
    public int lastIndexOf(Object o) &#123; 
        if (o == null) &#123;
            for (int i = size-1; i &gt;= 0; i--)
                if (elementData[i]==null)
                    return i; //返回该元素的下标
        &#125; else &#123;
            for (int i = size-1; i &gt;= 0; i--)
                if (o.equals(elementData[i]))
                    return i; //返回该元素的下标
        &#125;
        return -1; //没有找到返回-1
    &#125;</code></pre>
<h6 id="3-3-7-clone"><a href="#3-3-7-clone" class="headerlink" title="3.3.7 clone()"></a>3.3.7 clone()</h6><pre><code>//重写该Cloneable接口后写的clone方法，表示自己支持克隆，属于浅拷贝
    public Object clone() &#123; 
        try &#123;
            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        &#125; catch (CloneNotSupportedException e) &#123;
            // this shouldn&#39;t happen, since we are Cloneable
            throw new InternalError(e);
        &#125;
    &#125;</code></pre>
<h6 id="3-3-8-elementData-int-index"><a href="#3-3-8-elementData-int-index" class="headerlink" title="3.3.8 elementData(int index)"></a>3.3.8 elementData(int index)</h6><pre><code>// 位置访问操作
    @SuppressWarnings(&quot;unchecked&quot;)
    E elementData(int index) &#123;
        return (E) elementData[index];
    &#125;</code></pre>
<h6 id="3-3-9-get-int-index"><a href="#3-3-9-get-int-index" class="headerlink" title="3.3.9 get(int index)"></a>3.3.9 get(int index)</h6><pre><code>//返回指定下标的元素
public E get(int index) &#123;
    rangeCheck(index); //边界判断

    return elementData(index);
&#125;</code></pre>
<h6 id="3-3-10-set-int-index-E-element"><a href="#3-3-10-set-int-index-E-element" class="headerlink" title="3.3.10 set(int index, E element)"></a>3.3.10 set(int index, E element)</h6><pre><code>//把指定下标的元素设置为指定值
public E set(int index, E element) &#123;
    rangeCheck(index); //边界判断

    E oldValue = elementData(index); //取出旧值以便返回
    elementData[index] = element;
    return oldValue;
&#125;</code></pre>
<p>3.3.11 add(E e)</p>
<pre><code>/**
  * 将指定的元素附加到此列表的末尾。
  */
 public boolean add(E e) &#123; 
     ensureCapacityInternal(size + 1);  // 检查列表容量
     elementData[size++] = e;
     return true;
 &#125;</code></pre>
<h6 id="3-3-12-add-int-index-E-element"><a href="#3-3-12-add-int-index-E-element" class="headerlink" title="3.3.12 add(int index, E element)"></a>3.3.12 add(int index, E element)</h6><pre><code>/**
 * 将指定元素插入到列表中的指定位置。将当前位于该位置的元素(如果有)和任何后续元素向右移动(将一个元素添加到它们的索引中)。
 *
 */
public void add(int index, E element) &#123;
    rangeCheckForAdd(index); //边界判定
    ensureCapacityInternal(size + 1);  // 检查列表容量
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index); //将index位置的元素和后续元素向后移动一位
    elementData[index] = element; //将指定元素插入到指定的值
    size++;
&#125;</code></pre>
<h6 id="3-3-13-remove-int-index"><a href="#3-3-13-remove-int-index" class="headerlink" title="3.3.13 remove(int index)"></a>3.3.13 remove(int index)</h6><pre><code>//移除指定下标的元素
    public E remove(int index) &#123;
        rangeCheck(index); //边界判定，超出边界则抛出异常

        modCount++;
        E oldValue = elementData(index); //取出该位置下的值以便返回

        int numMoved = size - index - 1; //index位置后的后续元素的数量
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved); //将index位置后的后续元素向前移动一位
        elementData[--size] = null; //把原本列表末尾的值改为null

        return oldValue;
    &#125;</code></pre>
<h6 id="3-3-14-remove-Object-o"><a href="#3-3-14-remove-Object-o" class="headerlink" title="3.3.14 remove(Object o)"></a>3.3.14 remove(Object o)</h6><pre><code>//移除指定元素
    public boolean remove(Object o) &#123;
        if (o == null) &#123; //因为null没有equals方法，所以分开两种情况讨论
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) &#123;
                    fastRemove(index); //根据下标快速删除指定元素
                    return true;
                &#125;
        &#125; else &#123;
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) &#123;
                    fastRemove(index);
                    return true;
                &#125;
        &#125;
        return false;
    &#125;
    //快速删除方法，与remove方法类似，但是没有下标检查也不返回删除的元素
    private void fastRemove(int index) &#123;
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    &#125;</code></pre>
<h6 id="3-3-15-clear"><a href="#3-3-15-clear" class="headerlink" title="3.3.15 clear( )"></a>3.3.15 clear( )</h6><pre><code>/**
     * 从列表中删除所有元素。该调用返回后，列表将为空。
     */
    public void clear() &#123;
        modCount++;

        // clear to let GC do its work
        for (int i = 0; i &lt; size; i++) //逐一遍历，把值设置为null
            elementData[i] = null;

        size = 0;
    &#125;</code></pre>
<h6 id="3-3-16-addAll-Collection-lt-extends-E-gt-c"><a href="#3-3-16-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="3.3.16 addAll(Collection&lt;? extends E&gt; c)"></a>3.3.16 addAll(Collection&lt;? extends E&gt; c)</h6><pre><code>//将集合中的元素加入到列表的末尾
    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // 判断容量
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    &#125;</code></pre>
<h6 id="3-3-17-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#3-3-17-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="3.3.17 addAll(int index, Collection&lt;? extends E&gt; c)"></a>3.3.17 addAll(int index, Collection&lt;? extends E&gt; c)</h6><pre><code>//在指定的位置中插入集合元素
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;
        rangeCheckForAdd(index); //边界判定，超出边界则抛出异常

        Object[] a = c.toArray(); 
        int numNew = a.length; //获取集合的长度
        ensureCapacityInternal(size + numNew);  //检查列表容量

        int numMoved = size - index; //获取需要向后移动的元素的数量
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved); //将index位置上的元素及后续元素向后移动

        System.arraycopy(a, 0, elementData, index, numNew); //插入要插入的元素
        size += numNew; //改变列表的实际容量
        return numNew != 0;
    &#125;</code></pre>
<h6 id="3-3-18-removeRange-int-fromIndex-int-toIndex"><a href="#3-3-18-removeRange-int-fromIndex-int-toIndex" class="headerlink" title="3.3.18 removeRange(int fromIndex, int toIndex)"></a>3.3.18 removeRange(int fromIndex, int toIndex)</h6><pre><code>//删除指定范围的元素
protected void removeRange(int fromIndex, int toIndex) &#123;
    modCount++;
    int numMoved = size - toIndex; //获取toIndex位置后的后续元素的数量
    System.arraycopy(elementData, toIndex, elementData, fromIndex,
                     numMoved); //将toIndex位置后的后续元素复制到从fromIndex开始的位置

    // clear to let GC do its work
    int newSize = size - (toIndex-fromIndex); //获取删除后的元素数量
    for (int i = newSize; i &lt; size; i++) &#123; //将实际容量后的元素都设置null
        elementData[i] = null;
    &#125;
    size = newSize; //设置新的实际容量为删除后的元素数量
&#125;</code></pre>
<h6 id="3-3-19-rangeCheck-int-index-和-rangeCheckForAdd-int-index"><a href="#3-3-19-rangeCheck-int-index-和-rangeCheckForAdd-int-index" class="headerlink" title="3.3.19 rangeCheck(int index) 和 rangeCheckForAdd(int index)"></a>3.3.19 rangeCheck(int index) 和 rangeCheckForAdd(int index)</h6><pre><code>//边界判定的方法
   private void rangeCheck(int index) &#123;
       if (index &gt;= size) //如果下标大于等于数组的长度，则抛出异常
           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
   &#125;

   //边界判定的方法，用于插入元素，下标不能大于数组长度且小于0
   private void rangeCheckForAdd(int index) &#123;
       if (index &gt; size || index &lt; 0)
           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
   &#125;</code></pre>
<h6 id="3-3-20-removeAll-Collection-lt-gt-c"><a href="#3-3-20-removeAll-Collection-lt-gt-c" class="headerlink" title="3.3.20 removeAll(Collection&lt;?&gt; c)"></a>3.3.20 removeAll(Collection&lt;?&gt; c)</h6><pre><code>/**
 * 从该列表中删除指定集合中包含的所有元素。
 */
public boolean removeAll(Collection&lt;?&gt; c) &#123;
    Objects.requireNonNull(c);
    return batchRemove(c, false);
&#125;</code></pre>

        <!-- 分类文章 -->
        
          <div class="post-categoris-bottom">
            <div class="post-categoris-name">源码分析</div>
            <ul>
            
            
              
            
            
            
              
                <li class="me base">
                  <a  href="/2020/04/15/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-categoris-bottom-link">
                  ArrayList源码分析
                </a>
                </li>
              
              
            
            
            
              
                <li class="base">
                  <a  href="/2020/04/16/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-categoris-bottom-link">
                  HashMap源码分析
                </a>
                </li>
              
              
            
            
            
              
                <li class="base">
                  <a  href="/2020/04/18/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-categoris-bottom-link">
                  HashSet源码分析
                </a>
                </li>
              
              
            
            
            
              
                <li class="base">
                  <a  href="/2020/04/20/Hashtable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-categoris-bottom-link">
                  Hashtable源码分析
                </a>
                </li>
              
              
            
            
            
              
                <li class="base">
                  <a  href="/2020/04/22/Stack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-categoris-bottom-link">
                  Stack源码分析
                </a>
                </li>
              
              
            
            
            
              
                <li class="base">
                  <a  href="/2020/04/24/Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-categoris-bottom-link">
                  Vector源码分析
                </a>
                </li>
              
              
            
            
            
              
            
            
            
              
            
            
            
              
            
            
            </ul>

          </div>

        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>感谢你的观看，如有疑问请联系</p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://qo0581122.github.io/" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:1012428032@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="https://qo0581122.github.io/wechat/" target="_blank">
                <i class="ri-chat-1-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>

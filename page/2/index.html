<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-每天一条算法题20201101" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201101/" class="article-date">
  <time datetime="2020-10-31T16:00:00.000Z" itemprop="datePublished">2020-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201101/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-01"><a href="#每天一条算法题2020-11-01" class="headerlink" title="每天一条算法题2020/11/01"></a>每天一条算法题2020/11/01</h3><p>你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。</p>
<p>示例 1：</p>
<p>输入： pattern = “abba”, value = “dogcatcatdog”<br>输出： true<br>示例 2：</p>
<p>输入： pattern = “abba”, value = “dogcatcatfish”<br>输出： false<br>示例 3：</p>
<p>输入： pattern = “aaaa”, value = “dogcatcatdog”<br>输出： false<br>示例 4：</p>
<p>输入： pattern = “abba”, value = “dogdogdogdog”<br>输出： true<br>解释： “a”=”dogdog”,b=””，反之也符合规则<br>提示：</p>
<p>1 &lt;= len(pattern) &lt;= 1000<br>0 &lt;= len(value) &lt;= 1000<br>你可以假设pattern只包含字母”a”和”b”，value仅包含小写字母。</p>
<pre><code class="java">public boolean patternMatching(String pattern, String value) &#123;
        // 计算模式串中 a,b 的数量
        int countA = 0, countB = 0;
        for (char ch : pattern.toCharArray()) &#123;
            if (ch == &#39;a&#39;) &#123;
                ++countA;
            &#125; else &#123;
                ++countB;
            &#125;
        &#125;
        //如果 b 的数量大于 a 的数量，交换 a 和 b
        if (countA &lt; countB) &#123;
            int temp = countA;
            countA = countB;
            countB = temp;
            char[] array = pattern.toCharArray();
            for (int i = 0; i &lt; array.length; i++) &#123;
                array[i] = array[i] == &#39;a&#39; ? &#39;b&#39; : &#39;a&#39;;
            &#125;
            pattern = new String(array);
        &#125;
        //如果主串是空字符串，并且模式串只有一种子模式或模式串也是空字符串，则匹配成功，返回 true 。
        //否则失败，返回 false
        if (value.length() == 0) &#123;
            return countB == 0;
        &#125;
        //如果模式串是空字符串，并且主串非空，则匹配失败
        if (pattern.length() == 0) &#123;
            return false;
        &#125;
        for (int lenA = 0; countA * lenA &lt;= value.length(); ++lenA) &#123;
            //主串减去 countA 个长度为 lenA 的 a 子模式匹配值后剩余字符数量。
            //剩余部分是需要和 b 模式进行匹配，由于从模式串已知 b 子模式的数量，
            //从而可以计算出b的匹配值长度（必须是非负整数）
            int rest = value.length() - countA * lenA;
            // b 子模式匹配值长度为是非负整数时继续计算，否则匹配失败
            if ((countB == 0 &amp;&amp; rest == 0) || (countB != 0 &amp;&amp; rest % countB == 0)) &#123;
                //获取 b 子模式匹配值长度
                int lenB = (countB == 0 ? 0 : rest / countB);
                //每次分割起始位置
                int pos = 0;
                //记录当前子串是否匹配成功
                boolean correct = true;
                String valueA = &quot;&quot;, valueB = &quot;&quot;;
                //根据a 子模式和b 子模式匹配值长度和 a,b 在模式串里出现的先后顺序去分割主串。
                // 同时获得 a 子模式的匹配值和 b 子模式的匹配值
                for (char ch : pattern.toCharArray()) &#123;
                    if (ch == &#39;a&#39;) &#123;
                        String sub = value.substring(pos, pos + lenA);
                        if (valueA.length() == 0) &#123;
                            //a 子模式的匹配值
                            valueA = sub;
                        &#125; else if (!valueA.equals(sub)) &#123;
                            correct = false;
                            break;
                        &#125;
                        pos += lenA;
                    &#125; else &#123;
                        String sub = value.substring(pos, pos + lenB);
                        if (valueB.length() == 0) &#123;
                            //b 子模式的匹配值
                            valueB = sub;
                        &#125; else if (!valueB.equals(sub)) &#123;
                            correct = false;
                            break;
                        &#125;
                        pos += lenB;
                    &#125;
                &#125;
                //如果主串和模式串完全匹配，同时 a 子模式的匹配值和 b 子模式的匹配值不相同，则匹配成功
                if (correct &amp;&amp; !valueA.equals(valueB)) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201101/" data-id="ckidz590p0004louxhusz2bqt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习笔记2020-10-09" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02020-10-09/" class="article-date">
  <time datetime="2020-10-08T16:00:00.000Z" itemprop="datePublished">2020-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02020-10-09/">学习笔记2020-10-09</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Http请求中，get和post的区别"><a href="#Http请求中，get和post的区别" class="headerlink" title="Http请求中，get和post的区别"></a>Http请求中，get和post的区别</h1><ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<p>get请求和post请求都是基于TCP/IP协议，只是为了遵循http协议的规范，从而get请求在url上显示请求参数，post请求在request body内存放请求参数，而且请求的大小限制是根据浏览器和服务器的不成文规定来进行限制的。在运输层上的区别，get请求请求一次（只会发送一个TCP数据包），post请求会请求两次（会发送两个TCP数据包）。</p>
<h1 id="Https原理剖析"><a href="#Https原理剖析" class="headerlink" title="Https原理剖析"></a>Https原理剖析</h1><ul>
<li><p>对称加密：<strong>它的特点是文件加密和解密使用相同的密钥加密</strong></p>
</li>
<li><p>非对称加密：<strong>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。</strong></p>
<p><strong>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密</strong></p>
</li>
<li><p>Https在进行随机数加密，传输，解密的时候，用证书中的公钥来加密，用私钥来解密，是<strong>非对称加密</strong>。在浏览器验证了证书以后，会生成一串随机数字（例如<strong>123</strong>），并用证书包含的公钥来进行加密（变成<strong>abc</strong>），然后将加密的随机数发送给后端（后端接收到的是<strong>abc</strong>），后端会用私钥对随机数进行解密，获得最开始生成的随机数（例如<strong>123</strong>），后面的交互数据传输都会用该随机数（例如<strong>123</strong>）来进行加密，然后返回给浏览器，浏览器也会用该随机数来进行解密（浏览器随机生成的随机数在前后端交互中只传输了一次，且是加密传输）。也就是说后面的数据传输过程都是<strong>对称加密</strong>。（也就是说，证书中带有公钥，服务端被颁发证书的时候也会获取到该证书对应的私钥）</p>
</li>
</ul>
<h1 id="Volatile关键字原理剖析"><a href="#Volatile关键字原理剖析" class="headerlink" title="Volatile关键字原理剖析"></a>Volatile关键字原理剖析</h1><p>引用链接： <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg</a></p>
<h2 id="JMM（Java-memory-model）Java内存模型"><a href="#JMM（Java-memory-model）Java内存模型" class="headerlink" title="JMM（Java memory model）Java内存模型"></a>JMM（Java memory model）Java内存模型</h2><ul>
<li><p>不是实际存在的，只是一种规范。</p>
</li>
<li><p>因为CPU和内存的运算速度有几个数量级的差距，为了解决这个问题，所以现代计算机系统都加入了一层高速缓存来作为内存和cpu之间的缓冲，同时这也引发了新的问题，缓存一致性问题。当多个cpu对应多个高速缓存并且共享同一内存的时候，就引发了这个问题。</p>
</li>
<li><p>**Java内存模型(JavaMemoryModel)**描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。</p>
</li>
<li><p>所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
<p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>
<p>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</p>
<p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p>
</li>
</ul>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><ul>
<li><p>为什么要进行指令重排序？为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p>
</li>
<li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;</p>
</li>
<li><p>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;</p>
</li>
<li><p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</p>
</li>
</ul>
<h2 id="如何防止指令重排序"><a href="#如何防止指令重排序" class="headerlink" title="如何防止指令重排序"></a>如何防止指令重排序</h2><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止特定类型的处理器重排序。</p>
<h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p> 如果前一个操作(A)必须要对后一个操作（C）可见 ，那么这两个操作存在happens-before关系，那么这两个操作（A C） 指令不能重排。</p>
<h2 id="无法保证原子性"><a href="#无法保证原子性" class="headerlink" title="无法保证原子性"></a>无法保证原子性</h2><p>解决办法：要么用原子类，要么加锁</p>
<h3 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h3><ul>
<li><p>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p>
</li>
<li><p>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他(互斥)的机制。</p>
</li>
<li><p>volatile用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。</p>
</li>
<li><p>volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag;或者作为触发器，实现轻量级同步。</li>
<li>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</li>
<li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</li>
<li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主 存中读取。</li>
<li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</li>
<li>volatile可以使得long和double的赋值是原子的。</li>
<li>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02020-10-09/" data-id="ckidz590j0001louxbl7ehewp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bean的解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/15/Bean%E7%9A%84%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2020-09-14T16:00:00.000Z" itemprop="datePublished">2020-09-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/">Spring框架解析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/15/Bean%E7%9A%84%E8%A7%A3%E6%9E%90/">Bean的解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Bean的解析"><a href="#Bean的解析" class="headerlink" title="Bean的解析"></a>Bean的解析</h3><ul>
<li>位于AbstractApplicationContext.refresh（）方法</li>
<li>首先是preparerefresh（）方法。准备context（上下文）以进行刷新</li>
<li>对ConfigurableListableBeanFactory beanFactory用obtainFreshBeanFactory（）来进行实例化，告诉子类刷新内部bean工厂</li>
<li>prepareBeanFactory（beanFactory）。准备在context中使用bean工厂</li>
<li>postProcessBeanFactory（beanFactory）。允许在上下文子类中对bean工厂进行后处理。</li>
<li>invokeBeanFactoryPostProcessors（beanFactory）。把beanFactoryPostProcessors注册为bean</li>
<li>registerBeanPostProcessors（beanFactory）。注册拦截bean创建的beanPostProcessors</li>
<li>initMessageSource（）。初始化消息源</li>
<li>initApplicationEventMulticaster（）。初始化事件传播器</li>
<li>onRefresh（）。初始化其他特殊的bean。</li>
<li>registerListeners（）。初始化bean监听器。</li>
<li>finishBeanFactoryInitialization（beanFactory）。初始化剩余的单例bean（不包括lazy-init懒加载的bean）</li>
<li>finishRefresh（）。最后一步，发布相应的事件。</li>
<li>如果报错了：<ul>
<li>destoryBeans（）。销毁已经创建了的单例bean</li>
<li>cancelRefresh（e）。重置refresh的标志</li>
</ul>
</li>
</ul>
<h4 id="prepareRefresh（）"><a href="#prepareRefresh（）" class="headerlink" title="prepareRefresh（）"></a>prepareRefresh（）</h4><ul>
<li>更新startupDate的时间</li>
<li>设置refresh的标志为true</li>
<li>验证所有标记为必需的属性都是可解析的——getEnvironment().validateRequiredProperties();</li>
<li>实例化earlyApplicationEvents 为LinkedHashSet</li>
</ul>
<h4 id="AbstractEnvironment-validateRequiredProperties"><a href="#AbstractEnvironment-validateRequiredProperties" class="headerlink" title="AbstractEnvironment.validateRequiredProperties:"></a>AbstractEnvironment.validateRequiredProperties:</h4><ul>
<li>判断requiredProperties是否为空，不为空则抛出异常，requiredProperties默认为空</li>
</ul>
<h4 id="obtainFreshBeanFactory（）"><a href="#obtainFreshBeanFactory（）" class="headerlink" title="obtainFreshBeanFactory（）"></a>obtainFreshBeanFactory（）</h4><ul>
<li><p>由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory</p>
<ul>
<li><p>refreshBeanFactory（）</p>
<ul>
<li><p>首先判断beanFactory是否已经存在，如果存在则执行destory和close操作</p>
</li>
<li><p>创建一个DefaultListableBeanFactory对象</p>
</li>
<li><p>设置beanFactory的序列化id</p>
</li>
<li><p>执行<strong>customizeBeanFactory（beanFactory）</strong>（默认为不允许覆盖和不允许循环利用）</p>
</li>
<li><p>执行<strong>loadBeanDefinitions（beanFactory）**</strong>（核心）**</p>
<ul>
<li><p>创建<strong>xmlBeanDefinitionReader</strong>（xml中bean定义的读取器）</p>
</li>
<li><p>对<strong>reader</strong>进行初始化操作（设置环境，资源加载器，资源实体处理器）</p>
</li>
<li><p>执行<strong>initBeanDefinitionReader（beanDefinitionReader）</strong>方法（默认空实现）</p>
</li>
<li><p>执行<strong>loadBeanDefinitons（beanDefinitionReader）</strong>方法</p>
<ul>
<li><p>获取configResources资源数组</p>
</li>
<li><p>执行<strong>loadBeanDefinitions（String… locations）</strong>方法</p>
<ul>
<li>逐个location执行<strong>loadBeanDefinitions（String location， Set<Resource> actualResources）</strong>方法<ul>
<li>创建一个<strong>ResourceLoader</strong>的资源处理对象</li>
<li>执行**resourceLoader.getResoures(location)**方法<ul>
<li>对location根据命名规则来处理，查找该location下的所有资源</li>
<li>后面都是一些对标签进行解析的内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="prepareBeanFactory（beanFactory）"><a href="#prepareBeanFactory（beanFactory）" class="headerlink" title="prepareBeanFactory（beanFactory）"></a>prepareBeanFactory（beanFactory）</h4><h4 id="postProcessBeanFactory（beanFactory）"><a href="#postProcessBeanFactory（beanFactory）" class="headerlink" title="postProcessBeanFactory（beanFactory）"></a>postProcessBeanFactory（beanFactory）</h4><p>此方法允许子类在所有的bean尚未初始化之前注册BeanPostProcessor。空实现且没有子类覆盖。</p>
<h4 id="invokeBeanFactoryPostProcessors（beanFactory）"><a href="#invokeBeanFactoryPostProcessors（beanFactory）" class="headerlink" title="invokeBeanFactoryPostProcessors（beanFactory）"></a>invokeBeanFactoryPostProcessors（beanFactory）</h4><h4 id="registerBeanPostProcessors（beanFactory）"><a href="#registerBeanPostProcessors（beanFactory）" class="headerlink" title="registerBeanPostProcessors（beanFactory）"></a>registerBeanPostProcessors（beanFactory）</h4><h4 id="initMessageSource（）"><a href="#initMessageSource（）" class="headerlink" title="initMessageSource（）"></a>initMessageSource（）</h4><h4 id="initApplicationEventMulticaster（）"><a href="#initApplicationEventMulticaster（）" class="headerlink" title="initApplicationEventMulticaster（）"></a>initApplicationEventMulticaster（）</h4><h4 id="onRefresh（）"><a href="#onRefresh（）" class="headerlink" title="onRefresh（）"></a>onRefresh（）</h4><h4 id="registerListeners（）"><a href="#registerListeners（）" class="headerlink" title="registerListeners（）"></a>registerListeners（）</h4><h4 id="finishBeanFactoryInitialization（beanFactory）"><a href="#finishBeanFactoryInitialization（beanFactory）" class="headerlink" title="finishBeanFactoryInitialization（beanFactory）"></a>finishBeanFactoryInitialization（beanFactory）</h4><h4 id="finishRefresh（）"><a href="#finishRefresh（）" class="headerlink" title="finishRefresh（）"></a>finishRefresh（）</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/15/Bean%E7%9A%84%E8%A7%A3%E6%9E%90/" data-id="ckidz590d0000loux16jihimm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" rel="tag">Spring框架解析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-05-14T16:00:00.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>思路：每一轮选取未排定的部分中<strong>最小</strong>的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。</p>
<pre><code>public void sorted(int[] nums) &#123;
    for(int i = 0; i &lt; nums.length - 1; i++)&#123;
        int minIndex = i;
        for(int j = i + 1; j &lt; nums.length; j++)&#123;
            if(nums[i] &gt; nums[j])&#123;
                minIndex = j;
            &#125;
        &#125;
        int temp = nums[i];
        nums[i] = nums[minIndex];
        nums[minIndex] = temp;
    &#125;
&#125;</code></pre>
<p>时间复杂度O(N2)</p>
<p>空间复杂度O (1)</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>思路：暂存一个元素，然后之前元素逐个后移，留出空位，再把暂存的元素填补进空位，不断循环重复直到循环结束</p>
<pre><code>public int[] sortArray(int[] nums) &#123;
    int len = nums.length;
    // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
    for (int i = 1; i &lt; len; i++) &#123;
        // 先暂存这个元素，然后之前元素逐个后移，留出空位
        int temp = nums[i];
        int j = i;
        // 注意边界 j &gt; 0
        while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; temp) &#123;
            nums[j] = nums[j - 1];
            j--;
        &#125;
        nums[j] = temp;
    &#125;
    return nums;
&#125;</code></pre>
<p>时间复杂度：O(n2)</p>
<p>空间复杂度: O(1)</p>
<p>例题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a>。(<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/)%E3%80%82">https://leetcode-cn.com/problems/insertion-sort-list/)。</a></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并过程为：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>
<p>例题请参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p>
<p>经典例题：《剑指 Offer》第 51 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a>，照着归并排序的思路就能写出来。</p>
<p>「力扣」第 315 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a>，它们是一个问题。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>思路：现在我们的数组是这样的：<code>&#123;1,4,5,6,2,7,8,67,9,44&#125;</code>，既然我们<strong>比7小的在左边，比7大的在右边</strong>，那么我们只要将”左边“的排好顺序，又将”右边“的排好序，那整个数组是不是就有序了？想一想，是不是？</p>
<p>又回顾一下递归：”左边“的排好顺序，”右边“的排好序，跟我们<strong>第一趟排序的做法</strong>是不是一致的？</p>
<p><strong>只不过是参数不一样</strong>：第一趟排序是任选了一个支点，比支点小的在左边，比支点大的在右边。那么，我们想要”左边“的排好顺序，只要<strong>在”左边“部分找一个支点</strong>，比支点小的在左边，比支点大的在右边。</p>
<p>…………..最终可以得到一个有序的数组</p>
<p>基础版：</p>
<pre><code>public void quick(int[] arrays, int left, int right)&#123;
   if(left &gt;= right) return;
   int p = partition(arrays, left, right);
   quick(arrays, left, p-1);
   quick(arrays, p + 1, right);
&#125;

public int partition(int[] arrays, int left, int right) &#123;
   int base = arrays[left];
   int p = left; //用于记录小于base值的一个边界
   for (int i = left + 1; i &lt;= right; i++) &#123;
      if (arrays[i] &lt; base) &#123;//如果边界p的右边存在大于base的值，则把它与i的值交换，同时记录下新的边界值
         p++;
         swap(arrays, p, i);
         ;
      &#125;
   &#125;
   //因为base值此时在left的位置，而小于base的边界值在p的位置，
   // 则两个进行交换就可以保证p之前的数据都小于base，p之后的数据大于base
   swap(arrays, p, left);
   return p; //并将此时base的位置返回
&#125;

public void swap(int[] arrays, int i, int j)&#123;
   int temp = arrays[i];
   arrays[i] = arrays[j];
   arrays[j] = temp;
&#125;</code></pre>
<p>时间复杂度：O(N log⁡N)，这里 N 是数组的长度；<br>空间复杂度：O(log⁡N)，这里占用的空间主要来自递归函数的栈空间。</p>
<p>优化方法：</p>
<p>1、原本base值是选取最左边的元素，现在变为随机选取base值</p>
<p>2、可以设置一个阈值，当right - left + 1小于这个阈值的时候使用插入排序</p>
<p>使用「快速排序」解决的经典问题（非常重要）：</p>
<ul>
<li>TopK 问题：「力扣」第 215 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第 K 个最大元素</a>；</li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是选择排序的优化，选择排序需要在未排定的部分里通过「打擂台」的方式选出最大的元素（复杂度 O(N)O(N)O(N)），而「堆排序」就把未排定的部分构建成一个「堆」，这样就能以 O(log⁡N)O(\log N)O(logN) 的方式选出最大元素；<br>堆是一种相当有意思的数据结构，它在很多语言里也被命名为「优先队列」。它是建立在数组上的「树」结构，类似的数据结构还有「并查集」「线段树」等</p>
<p>作者：liweiwei1419<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/">https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="ckida46jx000a1ouxh0a22c4a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">计算机网络基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">计算机网络基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><h4 id="五层模型及其作用"><a href="#五层模型及其作用" class="headerlink" title="五层模型及其作用"></a>五层模型及其作用</h4><p>应用层：通过应用进程间的交互来完成特定的网络应用</p>
<p>传输层：负责向两台主机进程之间的通信提供通用的数据传输服务（提供数据传输服务（TCP/UDP））</p>
<p>网络层：选择合适的网间路由和交换结点，确保数据及时传送</p>
<p>数据链路层</p>
<p>物理层：实现相邻计算机结点之间比特流的透明传送，尽可能的屏蔽掉具体传输介质和物理设备的差异。</p>
<h4 id="TCP的三次请求"><a href="#TCP的三次请求" class="headerlink" title="TCP的三次请求"></a>TCP的三次请求</h4><p>第一次请求：客户端向服务器发送SYN=1,ACK=0,seq=x的数据报文</p>
<p>第二次请求：服务器收到连接请求后，向客户端发送SYN=1,ACK=1,ack=x+1，seq=y的数据报文。</p>
<p>第三次请求：客户端收到连接确认请求后，向客户端发送SYN=1,ack=y+1的数据报文。</p>
<p>三次请求后，TCP连接正式建立。</p>
<h5 id="为什么要进行三次握手呢？"><a href="#为什么要进行三次握手呢？" class="headerlink" title="为什么要进行三次握手呢？"></a>为什么要进行三次握手呢？</h5><p>通过第一次握手，服务器可以确认客户端的发送正常，自己的接受正常。</p>
<p>通过第二次握手，客户端可以确认自己的发送、接受正常，确认服务器的发送，接受正常。</p>
<p>通过第三次握手，服务器可以确认客户端的发送、接受正常，自己的发送、接受正常。</p>
<p>这样通过三次握手就保证形成了稳定可靠的通信通道。</p>
<h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><p>客户端A 发送连接释放报文，FIN=1给服务器B</p>
<p>B收到之后发出确认，此时TCP连接处于半关闭状态，B能向A发送数据，但是A不能向B发送数据。</p>
<p>当B不再需要连接时，会发送连接释放报文，FIN=1给A</p>
<p>A收到后发出确认，进入TIME_WAIT状态，等待2MSL后释放连接。</p>
<p>B收到A的确认后释放连接。</p>
<h4 id="TCP与UDP的区别？"><a href="#TCP与UDP的区别？" class="headerlink" title="TCP与UDP的区别？"></a>TCP与UDP的区别？</h4><p>TCP在发送数据之前需要建立起连接，再通过字节流的形式传输数据，是一个可靠连接。但是因为需要建立起连接的缘故，而且在传输的过程中为了保证传输的可靠性，会导致传输效率慢，占用资源多的问题。常用的场景为：文件传输等。</p>
<p>UDP在发送数据的时候不需要建立起连接，通过数据文段的形式进行传输，因为不需要建立起连接，所以不是一个可靠连接，而且在传输效率和占用资源方面会比TCP更快和更少。常用的场景为：语音，视频等。</p>
<h4 id="在浏览器输入URL地址后的一个过程。"><a href="#在浏览器输入URL地址后的一个过程。" class="headerlink" title="在浏览器输入URL地址后的一个过程。"></a>在浏览器输入URL地址后的一个过程。</h4><p>1、首先是通过DNS查询，找到URL地址所映射的IP地址。</p>
<p>2、根据IP地址发送HTTP请求，并建立起TCP连接。</p>
<p>3、服务器接收请求。</p>
<p>4、服务器对请求进行解析和处理，并返回一个HTML代码段。</p>
<p>5、浏览器根据服务器返回的HTML代码段对页面进行渲染。</p>
<p>6、将最终的页面呈现给用户</p>
<h4 id="DNS的一个寻址过程"><a href="#DNS的一个寻址过程" class="headerlink" title="DNS的一个寻址过程"></a>DNS的一个寻址过程</h4><p>1、查询浏览器缓存或者本地host文件，查看是否有该URL地址的映射</p>
<p>2、查询本地DNS缓存器</p>
<p>3、查询本地DNS服务器（URL地址包含在了本地配置区域资源中证明该域名是由本地DNS服务器进行解析，则返回该映射，且该结果具有权威性，该URL地址不由本地DNS服务器区域解析，但缓存了此网址的映射关系，则返回但是不具有权威性）</p>
<p>4、如果本地DNS失效，则查询下级DNS服务器</p>
<p>（不采用转发模式：把域名不断的下发到下一级DNS服务器，直到找到该域名的映射关系并进行返回给本地DNS服务器，再由本地DNS服务器进行返回</p>
<p>采用转发模式：把域名不断的转发到上一级DNS服务器，直到找到该域名的映射关系并进行返回给本地DNS服务器，再由本地DNS服务器进行返回</p>
<p>）</p>
<h4 id="SSL握手的四次过程"><a href="#SSL握手的四次过程" class="headerlink" title="SSL握手的四次过程"></a>SSL握手的四次过程</h4><p>1、客户端请求建立SSL连接，并向服务器发送一个随机数和客户端支持的加密方法，此时是明文传输。</p>
<p>2、服务端选择客户端支持的一个加密算法并生成另一个随机数，并将授信的服务端证书和公钥下发给客户端。</p>
<p>3、客户端收到服务端的回复后，会校验服务器证书的合法性，若合法，则生成一个新的随机数并通过服务端下发的公钥以及加密方式进行加密，然后发送给服务器。</p>
<p>4、服务器收到客户端的回复后，利用已确定的加密算法进行解密，同时利用上面的三个随机数通过一定的算法生成对称加密key，然后向客户端发送编码改变通知，表示随后的消息都将用双发商定好的加密算法进行加密，服务器握手结束通知，表示服务器的握手阶段已经结束。</p>
<p>此后，数据传输就通过对称加密方式进行加密传输</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>1xx：Informationnal信息性状态码，表示接受的请求正在处理。</p>
<p>2xx：Success成功状态码，表示请求已经正常处理完毕</p>
<p>3xx：Redirection重定向状态码，表示需要一些附加操作来完成请求</p>
<p>4xx：Client Error客户端错误状态码，表示服务器无法处理请求</p>
<p>5xx：Server Error服务器错误状态码，表示服务器处理请求出错。</p>
<h4 id="HTTP协议与TCP-IP协议的关系"><a href="#HTTP协议与TCP-IP协议的关系" class="headerlink" title="HTTP协议与TCP/IP协议的关系"></a>HTTP协议与TCP/IP协议的关系</h4><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p>
<h4 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的"></a>如何理解HTTP协议是无状态的</h4><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>
<h4 id="什么是长连接、短连接？"><a href="#什么是长连接、短连接？" class="headerlink" title="什么是长连接、短连接？"></a>什么是长连接、短连接？</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<pre><code>Connection:keep-alive</code></pre>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" data-id="ckida46jz000d1oux3vfz0p1a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="tag">计算机网络基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-05-01T16:00:00.000Z" itemprop="datePublished">2020-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式的几种例子</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h5 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a>懒汉</h5><pre><code>public class Singleton&#123;
    private static Singleton instance = null;
    public Singleton()&#123;&#125;;
    public synchronized Singleton getInstance()&#123;
        if(instance == null)&#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;</code></pre>
<h5 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h5><pre><code>public class Singleton&#123;
    private static Singleton instance = null;
    static&#123;
        instance = new Singleton();
    &#125;
    public Singleton()&#123;&#125;;
    public Singleton getInstance()&#123;
        return instance;
    &#125;
&#125;</code></pre>
<h5 id="双重校验"><a href="#双重校验" class="headerlink" title="双重校验"></a>双重校验</h5><pre><code>public class Singleton&#123;
    private volatile static Singleton instance = null;
    public Singleton()&#123;&#125;;

    public Singleton getInstance()&#123;
        if(instance == null)&#123;
            synchronized(Singleton.class)&#123;
                if(instance == null)&#123;
                    instance = new Singleton();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" data-id="ckida46jw00091ouxgoqq4p1v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vector源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-04-23T16:00:00.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>►<a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Vector/">Vector</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/24/Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Vector源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Vector源码分析"><a href="#Vector源码分析" class="headerlink" title="Vector源码分析"></a>Vector源码分析</h4><pre><code>public class Vector&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre>
<p>Vector类继承了AbstractList类，实现了List，RandomAccess，Cloneable，Serializable接口</p>
<p>List接口提供了一些基本的操作方法。</p>
<p>RandomAccess接口表示该类具有快速访问的功能。</p>
<p>Serializable接口表示该类支持进行序列化和反序列化的操作。</p>
<p>Vector的源码跟ArrayList类似，下面只阐述具有较大区别的方法。</p>
<p>此外，Vector的方法大部分都具有synchronized关键字修饰，所以是线程安全的。</p>
<h5 id="变量分析"><a href="#变量分析" class="headerlink" title="变量分析"></a>变量分析</h5><pre><code>//用于储存数据
protected Object[] elementData;

/**
 * 数据的数量
 */
protected int elementCount;

/**
 * 容量增量
 * 当向量的大小大于其容量时，向量的容量自动增加的量。
 * 如果容量增量小于或等于0，则每次需要增长时，向量的容量将增加一倍。
 *
 */
protected int capacityIncrement;

/** 
 * 序列化的版本号。用于反序列化。
 */
private static final long serialVersionUID = -2767605614048989439L;</code></pre>
<h5 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h5><pre><code>/**
 * 构造一个具有初始容量和容量增量的空向量
 */
public Vector(int initialCapacity, int capacityIncrement) &#123;
    super();
    if (initialCapacity &lt; 0) //如果初始容量小于0则抛出异常
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
&#125;

/**
 * 构造一个具有指定初始容量且其容量增量为零的空向量。
 */
public Vector(int initialCapacity) &#123;
    this(initialCapacity, 0);
&#125;

/**
 * 构造一个指定初始向量为10且其容量增量为0的空向量
 */
public Vector() &#123;
    this(10);
&#125;

/**
 * 构造一个向量，其中包含指定集合的元素，按集合的迭代器返回元素的顺序排列。
 *
 */
public Vector(Collection&lt;? extends E&gt; c) &#123;
    elementData = c.toArray();
    elementCount = elementData.length;
    // c.toArray might (incorrectly) not return Object[] (see 6260652)
    if (elementData.getClass() != Object[].class)
        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);
&#125;</code></pre>
<h5 id="Vector自动扩容的核心方法"><a href="#Vector自动扩容的核心方法" class="headerlink" title="Vector自动扩容的核心方法"></a>Vector自动扩容的核心方法</h5><pre><code>public synchronized void ensureCapacity(int minCapacity) &#123;
    if (minCapacity &gt; 0) &#123;
        modCount++;
        ensureCapacityHelper(minCapacity);
    &#125;
&#125;


private void ensureCapacityHelper(int minCapacity) &#123;
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0) //当最小容量参数大于当前容量时，执行grow方法
        grow(minCapacity);
&#125;


private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private void grow(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length;
    //新容量的值为旧容量 + 容量增量
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;

private static int hugeCapacity(int minCapacity) &#123;
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
&#125;</code></pre>
<p>大部分内容与ArrayList相似，其中最大的不同点是Vector的自动扩容的容量大小为当前容量加上容量增量的值。</p>
<p>其他常用方法与ArrayList类似，只是具有synchronized关键字修饰，下面列举几个常用方法。</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="size"><a href="#size" class="headerlink" title="size( )"></a>size( )</h6><pre><code>/**
 * 返回向量的长度
 */
public synchronized int size() &#123;
    return elementCount;
&#125;</code></pre>
<h6 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty( )"></a>isEmpty( )</h6><pre><code>/**
 * 返回向量是否为空
 *
 * @return  &#123;@code true&#125; if and only if this vector has
 *          no components, that is, its size is zero;
 *          &#123;@code false&#125; otherwise.
 */
public synchronized boolean isEmpty() &#123;
    return elementCount == 0;
&#125;</code></pre>
<h6 id="get（int-index）"><a href="#get（int-index）" class="headerlink" title="get（int index）"></a>get（int index）</h6><pre><code>/**
 * 返回指定位置的元素
 */
public synchronized E get(int index) &#123;
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
&#125;</code></pre>
<h6 id="set-int-index-e-element"><a href="#set-int-index-e-element" class="headerlink" title="set(int index, e element)"></a>set(int index, e element)</h6><pre><code>/**
 * 用指定的元素取代指定位置上的元素
 */
public synchronized E set(int index, E element) &#123;
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
&#125;</code></pre>
<h6 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h6><pre><code>/**
 * 增加元素，并返回增加结果(是否成功)
 */
public synchronized boolean add(E e) &#123;
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
&#125;</code></pre>
<h6 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h6><pre><code>/**
 * 删除指定元素并返回删除结果(是否成功)
 *
 * @param o element to be removed from this Vector, if present
 * @return true if the Vector contained the specified element
 * @since 1.2
 */
public boolean remove(Object o) &#123;
    return removeElement(o);
&#125;</code></pre>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Vector与ArrayList类似，区别在于扩容机制的不同，Vector的扩容值为当前容量加上容量增量的值，ArrayList的扩容值为当前容量加上当前容量的一半。还有一个区别就是Vector的方法都具有synchronziable关键字修饰，所以Vector是相对线程安全的，但由于存在重量锁，所以效率上没有ArrayList快。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/24/Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckida46jv00061oux6rrk9wrn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vector/" rel="tag">Vector</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Stack源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/Stack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-04-21T16:00:00.000Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>►<a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Stack/">Stack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/Stack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Stack源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Stack源码分析"><a href="#Stack源码分析" class="headerlink" title="Stack源码分析"></a>Stack源码分析</h4><h5 id="从类名结构分析"><a href="#从类名结构分析" class="headerlink" title="从类名结构分析"></a>从类名结构分析</h5><pre><code>public
class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;</code></pre>
<p>是Vector的子类，所以Stack等于是在Vector上的进一步操作。</p>
<p>变量分析</p>
<p>Stack覆盖了Vector的serialVersionUID</p>
<pre><code>private static final long serialVersionUID = 1224463164541339165L;</code></pre>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code>public Stack() &#123;
&#125;</code></pre>
<p>只有一个默认的不带参数的构造方法</p>
<h5 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h5><h6 id="push-E-item"><a href="#push-E-item" class="headerlink" title="push(E item)"></a>push(E item)</h6><pre><code>/**
 * 将一个对象推到堆栈的顶部。
 */
public E push(E item) &#123;
    addElement(item);

    return item;
&#125;</code></pre>
<h6 id="pop"><a href="#pop" class="headerlink" title="pop( )"></a>pop( )</h6><pre><code>/**
 * 删除堆栈顶部的对象并返回该对象
 */
public synchronized E pop() &#123;
    E       obj;
    int     len = size();

    obj = peek();
    removeElementAt(len - 1);

    return obj;
&#125;</code></pre>
<h6 id="peek"><a href="#peek" class="headerlink" title="peek( )"></a>peek( )</h6><pre><code>/**
 * 查看此堆栈顶部的对象，但不将其从堆栈中删除。
 */
public synchronized E peek() &#123;
    int     len = size();

    if (len == 0)
        throw new EmptyStackException();
    return elementAt(len - 1);
&#125;</code></pre>
<h6 id="empty"><a href="#empty" class="headerlink" title="empty( )"></a>empty( )</h6><pre><code>/**
 * 测试堆栈是否为空
 *
 */
public boolean empty() &#123;
    return size() == 0;
&#125;</code></pre>
<h6 id="search-Object-o"><a href="#search-Object-o" class="headerlink" title="search(Object o)"></a>search(Object o)</h6><pre><code>/**
 * 在堆栈中查找指定的元素
 */
public synchronized int search(Object o) &#123;
    int i = lastIndexOf(o);

    if (i &gt;= 0) &#123;
        return size() - i;
    &#125;
    return -1;
&#125;</code></pre>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>底层原理还是Vector，也就是数组，只是在Vector的基础上增添了几个方法，修改了一下增加元素删除元素的基本逻辑</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/22/Stack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckida46ju00051oux7dqubjhd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Stack/" rel="tag">Stack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hashtable源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/20/Hashtable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-04-19T16:00:00.000Z" itemprop="datePublished">2020-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>►<a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Hashtable/">Hashtable</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/20/Hashtable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Hashtable源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Hashtable源码分析"><a href="#Hashtable源码分析" class="headerlink" title="Hashtable源码分析"></a>Hashtable源码分析</h4><h5 id="类结构分析"><a href="#类结构分析" class="headerlink" title="类结构分析"></a>类结构分析</h5><pre><code>public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</code></pre>
<h5 id="变量分析"><a href="#变量分析" class="headerlink" title="变量分析"></a>变量分析</h5><pre><code>**
 * 哈希表。用于存储数据
 */
private transient Entry&lt;?,?&gt;[] table;

/**
 * 哈希表中的数据条目总数。
 */
private transient int count;

/**
 * 当表的大小超过此阈值时，将对其进行重新哈希。(该字段的值是(int)(capacity * loadFactor)。)
 * 即当表的大小超过此阈值，重新建立一个容量更大的哈希表。
 * @serial
 */
private int threshold;

/**
 * 哈希表的负载因子
 *
 * @serial
 */
private float loadFactor;

/**
 * 从结构上修改此哈希表的次数
 */
private transient int modCount = 0;

/** 版本号 */
private static final long serialVersionUID = 1421746759512286392L;

/**
  * 数组的最大长度
  */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</code></pre>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code>/**
 * 使用指定的初始容量和指定的负载因子构造新的空哈希表。
 */
public Hashtable(int initialCapacity, float loadFactor) &#123;
    if (initialCapacity &lt; 0) //如果指定的初始容量小于0则抛出异常
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) //如果指定的负载因子不是float并且小于等于0则抛出异常
        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);

    if (initialCapacity==0) //如果指定的初始容量为0，则更改为1
        initialCapacity = 1;
    this.loadFactor = loadFactor;
    table = new Entry&lt;?,?&gt;[initialCapacity];
    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); //设置阈值
&#125;

/**
 * 使用指定的初始容量和默认负载因子(0.75)构造一个新的空哈希表。
 */
public Hashtable(int initialCapacity) &#123;
    this(initialCapacity, 0.75f);
&#125;

/**
 * 使用默认初始容量(11)和负载因子(0.75)构造一个新的空哈希表。
 */
public Hashtable() &#123;
    this(11, 0.75f);
&#125;

/**
 * 使用与给定映射相同的映射构造新的哈希表。hashtable的初始容量足以容纳给定映射中的映射，并具有默认的负载因子(0.75)。
 *
 */
public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;
    this(Math.max(2*t.size(), 11), 0.75f);
    putAll(t);
&#125;</code></pre>
<h5 id="核心方法（自动扩容机制）"><a href="#核心方法（自动扩容机制）" class="headerlink" title="核心方法（自动扩容机制）"></a>核心方法（自动扩容机制）</h5><pre><code>/**
 * 增加此散列表的容量并在内部重新组织此散列表，以便更有效地容纳和访问其条目。当哈希表中的键数超过此哈希表的容量和负载因子时，将自动调用此方法。
 */
@SuppressWarnings(&quot;unchecked&quot;)
protected void rehash() &#123;
    int oldCapacity = table.length; //获取哈希表的长度
    Entry&lt;?,?&gt;[] oldMap = table; //获取旧的哈希表

    // overflow-conscious code
    int newCapacity = (oldCapacity &lt;&lt; 1) + 1; //获取旧的哈希表的长度的两倍再加一
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; //如果新的容量大于数组的最大长度，则设置新的容量为数组的最大长度
        if (oldCapacity == MAX_ARRAY_SIZE)
            // Keep running with MAX_ARRAY_SIZE buckets
            return;
        newCapacity = MAX_ARRAY_SIZE;
    &#125;
    Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; //构造具有新容量的空的哈希表

    modCount++;
    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); //设置新的阈值
    table = newMap; //设置新的表

    for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; //对哈希表进行反向遍历
        for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123; //对结点的链表进行遍历
            Entry&lt;K,V&gt; e = old;
            old = old.next;

            int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; //获取该结点在新表中的位置
            e.next = (Entry&lt;K,V&gt;)newMap[index]; 
            newMap[index] = e;
        &#125; //在新表中链表的顺序倒了过来，被逆序了。
    &#125;
&#125;</code></pre>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="get（Object-key）"><a href="#get（Object-key）" class="headerlink" title="get（Object key）"></a>get（Object key）</h6><pre><code>/**
 * 返回指定键映射到的值，如果此映射不包含键的映射，则返回null
 */
@SuppressWarnings(&quot;unchecked&quot;)
public synchronized V get(Object key) &#123;
    Entry&lt;?,?&gt; tab[] = table; //获取哈希表
    int hash = key.hashCode(); //获取key的哈希码
    int index = (hash &amp; 0x7FFFFFFF) % tab.length; //获取哈希码所对应的哈希表的位置
    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; //如果该位置上存在结点，则对其进行遍历
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;
            return (V)e.value;
        &#125;
    &#125;
    return null;
&#125;</code></pre>
<h6 id="put（K-key-V-value）"><a href="#put（K-key-V-value）" class="headerlink" title="put（K key, V value）"></a>put（K key, V value）</h6><pre><code>/**
 * 将指定的键映射到此散列表中指定的值。键和值都不能是null
 *
 * 可以通过调用get方法来检索该值，该方法的键值等于原始键值。
 */
public synchronized V put(K key, V value) &#123;
    // 确保值不能为null，否则抛出异常
    if (value == null) &#123;
        throw new NullPointerException();
    &#125;

    // 确保key在表中没有映射
    Entry&lt;?,?&gt; tab[] = table; //获取哈希表
    int hash = key.hashCode(); //获取key的哈希码
    int index = (hash &amp; 0x7FFFFFFF) % tab.length; //获取该哈希码所映射的哈希表的位置
    @SuppressWarnings(&quot;unchecked&quot;)
    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; //获取该位置上的Entry结点
    for(; entry != null ; entry = entry.next) &#123; //如果Entry为链表结构则进行遍历
        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;
            V old = entry.value;
            entry.value = value;
            return old; //如果已经存在该映射，则返回已经被映射的值
        &#125;
    &#125;

    addEntry(hash, key, value, index); //增加新的映射
    return null;
&#125;
private void addEntry(int hash, K key, V value, int index) &#123;
        modCount++;

        Entry&lt;?,?&gt; tab[] = table; //获取哈希表
        if (count &gt;= threshold) &#123;
            // 如果哈希表的数据数目大于阈值则进行扩容
            rehash();

            tab = table;
            hash = key.hashCode();
            index = (hash &amp; 0x7FFFFFFF) % tab.length;
        &#125;

        // Creates the new entry.
        @SuppressWarnings(&quot;unchecked&quot;)
        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];
        tab[index] = new Entry&lt;&gt;(hash, key, value, e); //将新结点作为链表的头结点加入到哈希表对应的位置上
        count++;
    &#125;</code></pre>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>Hashtable的哈希表结构为数组加链表的形式。</p>
<p>在自动扩容的过程中。链表被逆序链接在新表上。</p>
<p>根据Key哈希码并经过一个算法来判断此映射在哈希表上的位置。</p>
<p>在加入结点的过程中，会把新结点作为链表的头结点加入到哈希表对应的位置上</p>
<p>Hashtable的方法都上了锁（被synchronized关键字修饰），所以是相对线程安全的。</p>
<p>当不指定初始容量时，Hashtable的默认容量为11。</p>
<p>如果原本的容量为n，则经过自动扩容后的容量为2n+1.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/20/Hashtable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckida46jq00011oux9djc1jcl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hashtable/" rel="tag">Hashtable</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HashSet源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/18/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-04-17T16:00:00.000Z" itemprop="datePublished">2020-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>►<a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashSet/">HashSet</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/18/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">HashSet源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a>HashSet源码分析</h4><h5 id="从类结构分析"><a href="#从类结构分析" class="headerlink" title="从类结构分析"></a>从类结构分析</h5><pre><code>public class HashSet&lt;E&gt;
    extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable
&#123;</code></pre>
<p>继承了AbstractSet类，实现了Set，Cloneable，Serializable接口</p>
<p>Set接口提供了操作Set的基本方法</p>
<p>Cloneable接口表示HashSet支持克隆操作</p>
<p>Serializablle接口表示HashSet可以进行序列化和反序列化操作</p>
<h5 id="变量分析"><a href="#变量分析" class="headerlink" title="变量分析"></a>变量分析</h5><pre><code>static final long serialVersionUID = -5024744406713321676L; //序列化版本号

private transient HashMap&lt;E,Object&gt; map; //HashSet的底层结构为HashMap

// 将哑值与备份映射中的对象关联
private static final Object PRESENT = new Object();</code></pre>
<h5 id="构造方法解析"><a href="#构造方法解析" class="headerlink" title="构造方法解析"></a>构造方法解析</h5><pre><code>/**
 * 构造一个新的空集;支持HashMap实例具有默认的初始容量(16)和负载因子(0.75)。
 */
public HashSet() &#123;
    map = new HashMap&lt;&gt;();
&#125;

/**
 * 构造一个新集合，该集合包含指定集合中的元素。HashMap是使用默认的负载因子(0.75)和足够容纳指定集合中的元素的初始容量（16）创建的。
 *
 * @param c the collection whose elements are to be placed into this set
 * @throws NullPointerException if the specified collection is null
 */
public HashSet(Collection&lt;? extends E&gt; c) &#123;
    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
&#125;

/**
 * 构造一个新的空集;支持HashMap实例具有指定的初始容量和指定的负载因子。
 *
 * @param      initialCapacity   the initial capacity of the hash map
 * @param      loadFactor        the load factor of the hash map
 * @throws     IllegalArgumentException if the initial capacity is less
 *             than zero, or if the load factor is nonpositive
 */
public HashSet(int initialCapacity, float loadFactor) &#123;
    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);
&#125;

/**
 * 构造一个新的空集;支持HashMap实例具有指定的初始容量和初始负载因子(0.75)。
 *
 * @param      initialCapacity   the initial capacity of the hash table
 * @throws     IllegalArgumentException if the initial capacity is less
 *             than zero
 */
public HashSet(int initialCapacity) &#123;
    map = new HashMap&lt;&gt;(initialCapacity);
&#125;

/**
 * 构造一个新的空的链接哈希集(这个包的私有构造函数只被LinkedHashSet使用)。支持的HashMap实例是一个LinkedHashMap，它具有指定的初始容量和指定的负载因子。
 *
 * @param      initialCapacity   the initial capacity of the hash map
 * @param      loadFactor        the load factor of the hash map
 * @param      dummy             ignored (distinguishes this
 *             constructor from other int, float constructor.)
 * @throws     IllegalArgumentException if the initial capacity is less
 *             than zero, or if the load factor is nonpositive
 */
HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;
    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
&#125;</code></pre>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="add（）"><a href="#add（）" class="headerlink" title="add（）"></a>add（）</h6><pre><code>/**
 * 如果指定的元素尚未出现，则将其添加到此集合。如果这个集合已经包含元素，那么调用将保持集合不变，并返回false。
 *
 * @param e element to be added to this set
 * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified
 * element
 */
public boolean add(E e) &#123;
    return map.put(e, PRESENT)==null;
&#125;</code></pre>
<h6 id="remove（）"><a href="#remove（）" class="headerlink" title="remove（）"></a>remove（）</h6><pre><code>/**
 * 如果指定的元素存在，则从该集合中移除它。更正式地说，删除一个元素e，如果该集合包含元素，则返回true
 *
 * @param o object to be removed from this set, if present
 * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element
 */
public boolean remove(Object o) &#123;
    return map.remove(o)==PRESENT;
&#125;</code></pre>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>HashSet的底层结构为HashMap，则扩容机制初始容量等都于HashMap相同。</p>
<p>HashSet的方法也是调用HashMap的方法。</p>
<p>调用方法的原理：其实就是把你要存入HashSet的元素E e当成HashMap的Key来存入HashMap的映射表中。HashMap的结点中的Value就用同一的具有final修饰符修饰的变量PRESETN，这就可以保证了HashSet的唯一性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/18/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckida46jt00041ouxfhldhq87" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashSet/" rel="tag">HashSet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9D%91/">坑</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9D%91/MySQL/">MySQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/">Spring框架解析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap/">HashMap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashSet/">HashSet</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Hashtable/">Hashtable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Stack/">Stack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Vector/">Vector</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">计算机网络基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashSet/" rel="tag">HashSet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashtable/" rel="tag">Hashtable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" rel="tag">Spring框架解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack/" rel="tag">Stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vector/" rel="tag">Vector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9D%91/" rel="tag">坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="tag">计算机网络基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/HashSet/" style="font-size: 10px;">HashSet</a> <a href="/tags/Hashtable/" style="font-size: 10px;">Hashtable</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">Spring框架解析</a> <a href="/tags/Stack/" style="font-size: 10px;">Stack</a> <a href="/tags/Vector/" style="font-size: 10px;">Vector</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">单例模式</a> <a href="/tags/%E5%9D%91/" style="font-size: 10px;">坑</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">学习笔记</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">排序算法</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 16.67px;">源码分析</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">计算机网络基础</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201110/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201109/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201108/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201107/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201106/">每天一条算法题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
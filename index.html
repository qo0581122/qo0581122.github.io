
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Franklin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Franklin">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Franklin">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Franklin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Franklin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.2.0"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Franklin</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="example.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-每天一条算法题20201110" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201110/" class="article-date">
  <time datetime="2020-11-09T16:00:00.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201110/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-10"><a href="#每天一条算法题2020-11-10" class="headerlink" title="每天一条算法题2020/11/10"></a>每天一条算法题2020/11/10</h3><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: </p>
<p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。<br>示例 1:</p>
<p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。<br>示例 2:</p>
<p>输入:<br>gas  = [2,3,4]<br>cost = [3,4,3]</p>
<p>输出: -1</p>
<p>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station">https://leetcode-cn.com/problems/gas-station</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>若要满足题目的要求：跑完全程再回到起点，总油量剩余值的任意部分都需要在X轴以上，且跑到终点时：总剩余汽油量 &gt;= 0。</p>
<p>为了让黑色折线图任意部分都在 X 轴以上，我们需要向上移动黑色折线图，直到所有点都在X轴或X轴以上。此时，处在X轴的点即为出发点。即黑色折线图的最低值的位置：index = 3。</p>
<pre><code class="java">public int canCompleteCircuit(int[] gas, int[] cost) &#123;
    int len = gas.length;
    int spare = 0;
    int minSpare = Integer.MAX_VALUE;
    int minIndex = 0;

    for (int i = 0; i &lt; len; i++) &#123;
        spare += gas[i] - cost[i];
        if (spare &lt; minSpare) &#123;
            minSpare = spare;
            minIndex = i;
        &#125;
    &#125;

    return spare &lt; 0 ? -1 : (minIndex + 1) % len;
&#125;

作者：cyaycz
链接：https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201110/" data-id="ckidz5912000xlouxauvh8bd6" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201110/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201109" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201109/" class="article-date">
  <time datetime="2020-11-08T16:00:00.000Z" itemprop="datePublished">2020-11-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201109/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-09"><a href="#每天一条算法题2020-11-09" class="headerlink" title="每天一条算法题2020/11/09"></a>每天一条算法题2020/11/09</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：</p>
<p>输入：s = “a”, t = “a”<br>输出：”a”</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring">https://leetcode-cn.com/problems/minimum-window-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">class Solution &#123;
    public String minWindow(String s, String t) &#123;
        if (s == null || s == &quot;&quot; || t == null || t == &quot;&quot; || s.length() &lt; t.length()) &#123;
            return &quot;&quot;;
        &#125;
        //维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数
        //ASCII表总长128
        int[] need = new int[128];
        int[] have = new int[128];

        //将目标字符串指定字符的出现次数记录
        for (int i = 0; i &lt; t.length(); i++) &#123;
            need[t.charAt(i)]++;
        &#125;

        //分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)
        //已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置
        int left = 0, right = 0, min = s.length() + 1, count = 0, start = 0;
        while (right &lt; s.length()) &#123;
            char r = s.charAt(right);
            //说明该字符不被目标字符串需要，此时有两种情况
            // 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断
            // 2.循环已经开始一段时间，此处又有两种情况
            //  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时
            //      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可
            //  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针
            if (need[r] == 0) &#123;
                right++;
                continue;
            &#125;
            //当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1
            //是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数
            if (have[r] &lt; need[r]) &#123;
                count++;
            &#125;
            //已有字符串中目标字符出现的次数+1
            have[r]++;
            //移动右指针
            right++;
            //当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次
            while (count == t.length()) &#123;
                //挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置
                if (right - left &lt; min) &#123;
                    min = right - left;
                    start = left;
                &#125;
                char l = s.charAt(left);
                //如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针
                if (need[l] == 0) &#123;
                    left++;
                    continue;
                &#125;
                //如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，
                //就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1
                if (have[l] == need[l]) &#123;
                    count--;
                &#125;
                //已有字符串中目标字符出现的次数-1
                have[l]--;
                //移动左指针
                left++;
            &#125;
        &#125;
        //如果最小长度还为初始值，说明没有符合条件的子串
        if (min == s.length() + 1) &#123;
            return &quot;&quot;;
        &#125;
        //返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串
        return s.substring(start, start + min);
    &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201109/" data-id="ckidz5911000tloux709qf1fs" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201109/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201108" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201108/" class="article-date">
  <time datetime="2020-11-07T16:00:00.000Z" itemprop="datePublished">2020-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201108/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-08"><a href="#每天一条算法题2020-11-08" class="headerlink" title="每天一条算法题2020/11/08"></a>每天一条算法题2020/11/08</h3><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p>说明：</p>
<p>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p>
<p>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]<br>示例 2：</p>
<p>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break-ii">https://leetcode-cn.com/problems/word-break-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">class Solution &#123;
    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;
        Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map = new HashMap&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt;();
        List&lt;List&lt;String&gt;&gt; wordBreaks = backtrack(s, s.length(), new HashSet&lt;String&gt;(wordDict), 0, map);
        List&lt;String&gt; breakList = new LinkedList&lt;String&gt;();
        for (List&lt;String&gt; wordBreak : wordBreaks) &#123; //把答案格式进行重新组装
            breakList.add(String.join(&quot; &quot;, wordBreak));
        &#125;
        return breakList;
    &#125;

    public List&lt;List&lt;String&gt;&gt; backtrack(String s, int length, Set&lt;String&gt; wordSet, int index, Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map) &#123;
        if (!map.containsKey(index)) &#123;
            List&lt;List&lt;String&gt;&gt; wordBreaks = new LinkedList&lt;List&lt;String&gt;&gt;();
            if (index == length) &#123;
                wordBreaks.add(new LinkedList&lt;String&gt;());
            &#125;
            for (int i = index + 1; i &lt;= length; i++) &#123;
                String word = s.substring(index, i);
                if (wordSet.contains(word)) &#123;
                    //递归下去，直到最后找到最后一个匹配的单词，在往前找匹配的单词。
                    List&lt;List&lt;String&gt;&gt; nextWordBreaks = backtrack(s, length, wordSet, i, map);
                    //因为会出现多个不同单词匹配的情况，所以用list来存储数据。
                    for (List&lt;String&gt; nextWordBreak : nextWordBreaks) &#123;
                        LinkedList&lt;String&gt; wordBreak = new LinkedList&lt;String&gt;(nextWordBreak);
                        //把当前匹配的单词加到list的前面。
                        wordBreak.offerFirst(word);
                        wordBreaks.add(wordBreak);
                    &#125;
                &#125;
            &#125;
            //记录当前位置的单词不同的匹配方案。有利于提高运行效率。
            map.put(index, wordBreaks);
        &#125;
        return map.get(index);
    &#125;
&#125;

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/word-break-ii/solution/dan-ci-chai-fen-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201108/" data-id="ckidz5910000rloux9lqvexsi" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201108/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201107" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201107/" class="article-date">
  <time datetime="2020-11-06T16:00:00.000Z" itemprop="datePublished">2020-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201107/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-07"><a href="#每天一条算法题2020-11-07" class="headerlink" title="每天一条算法题2020/11/07"></a>每天一条算法题2020/11/07</h3><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p>
<p>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。<br>示例 2：</p>
<p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break">https://leetcode-cn.com/problems/word-break</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">//动态规划
class Solution &#123;
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;
        Set&lt;String&gt; set = new HashSet&lt;&gt;(wordDict); //去重
        boolean[] dp = new boolean[s.length() + 1]; //dp[i] 表示的是0-i位置的字符串是否可拆。
        dp[0] = true;
        for (int i = 1; i &lt;= s.length(); i++) &#123;
            for (int j = 0; j &lt; i; j++) &#123; //把字符串分割成左右两个字符串，左边的字符串可在dp中得出
                if(dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;
                    dp[i] = true;
                    break;
                &#125;
            &#125;
        &#125;
        return dp[s.length()];
    &#125;
&#125;</code></pre>
<pre><code class="java">//执行效率最高：递归
class Solution &#123;
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;
        if (s.length() == 0) &#123; //当s长度为0的时候说明经过递归截取字符串后，该字符串是可拆分的。
            return true;
        &#125;
        if (s.length() &gt; 149) &#123;
            return false;
        &#125;
        int size = s.length();
        boolean ans = false;
        for (int i = 0; i &lt; wordDict.size(); i++) &#123;
            if (s.startsWith(wordDict.get(i))) &#123; //找到是需要查找的字符串开头的字符串数组中的字符串
                ans = wordBreak(s.substring(wordDict.get(i).length()), wordDict); //继续查找后续的字符串
                if (ans) break;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201107/" data-id="ckidz590y000llouxes0ogee6" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201107/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201106" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201106/" class="article-date">
  <time datetime="2020-11-05T16:00:00.000Z" itemprop="datePublished">2020-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201106/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-06"><a href="#每天一条算法题2020-11-06" class="headerlink" title="每天一条算法题2020/11/06"></a>每天一条算法题2020/11/06</h3><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 1:</p>
<p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p>
<p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses">https://leetcode-cn.com/problems/longest-valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">class Solution &#123;
    public int longestValidParentheses(String s) &#123;
        if (s.length() == 0 || s.length() == 1) return 0;
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        stack.push(-1); //用于防止首字符为）而出现的异常，至于为什么是-1，因为后面减的时候可以统计最长有效元素的个数
        int max = 0;
        for (int i = 0; i &lt; s.length(); i++) &#123;
            char c = s.charAt(i);
            if (c == &#39;(&#39;) &#123; //因为插入（ 字符不会形成有效字符串，所以直接插入就好。
                stack.push(i);
            &#125;else &#123; //因为一开始栈就插入了-1，所以可以直接出栈。如果栈顶元素为（ ,刚好出栈形成配对。
                stack.pop();
                if (stack.empty()) &#123; //出栈以后可能会存在栈空的情况，就把当前元素的位置入栈。
                    stack.push(i);
                &#125;else &#123; //如果栈不为空，则存在最长有效元素
                    max = Math.max(max, i - stack.peek());
                &#125;
            &#125;
        &#125;
        return max;
    &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201106/" data-id="ckidz590z000nlouxey3692od" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201106/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-排序算法之重新总结归纳" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%87%8D%E6%96%B0%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/" class="article-date">
  <time datetime="2020-11-04T16:00:00.000Z" itemprop="datePublished">2020-11-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%87%8D%E6%96%B0%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/">排序算法之重新总结归纳</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code class="java">public class Solution &#123;
    // 归并排序

    /**
     * 列表大小等于或小于该大小，将优先于 mergeSort 使用插入排序
     */
    private static final int INSERTION_SORT_THRESHOLD = 7;

    public int[] sortArray(int[] nums) &#123;
        int len = nums.length;
        int[] temp = new int[len];
        mergeSort(nums, 0, len - 1, temp);
        return nums;
    &#125;

    /**
     * 对数组 nums 的子区间 [left, right] 进行归并排序
     *
     * @param nums
     * @param left
     * @param right
     * @param temp  用于合并两个有序数组的辅助数组，全局使用一份，避免多次创建和销毁
     */
    private void mergeSort(int[] nums, int left, int right, int[] temp) &#123;
        // 小区间使用插入排序
        if (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;
            insertionSort(nums, left, right);
            return;
        &#125;

        int mid = left + (right - left) / 2;
        // Java 里有更优的写法，在 left 和 right 都是大整数时，即使溢出，结论依然正确
        // int mid = (left + right) &gt;&gt;&gt; 1;

        mergeSort(nums, left, mid, temp);
        mergeSort(nums, mid + 1, right, temp);
        // 如果数组的这个子区间本身有序，无需合并
        if (nums[mid] &lt;= nums[mid + 1]) &#123;
            return;
        &#125;
        mergeOfTwoSortedArray(nums, left, mid, right, temp);
    &#125;

    /**
     * 对数组 arr 的子区间 [left, right] 使用插入排序
     *
     * @param arr   给定数组
     * @param left  左边界，能取到
     * @param right 右边界，能取到
     */
    private void insertionSort(int[] arr, int left, int right) &#123;
        for (int i = left + 1; i &lt;= right; i++) &#123;
            int temp = arr[i];
            int j = i;
            while (j &gt; left &amp;&amp; arr[j - 1] &gt; temp) &#123;
                arr[j] = arr[j - 1];
                j--;
            &#125;
            arr[j] = temp;
        &#125;
    &#125;

    /**
     * 合并两个有序数组：先把值复制到临时数组，再合并回去
     *
     * @param nums
     * @param left
     * @param mid   [left, mid] 有序，[mid + 1, right] 有序
     * @param right
     * @param temp  全局使用的临时数组
     */
    private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right, int[] temp) &#123;
        System.arraycopy(nums, left, temp, left, right + 1 - left);

        int i = left;
        int j = mid + 1;

        for (int k = left; k &lt;= right; k++) &#123;
            if (i == mid + 1) &#123;
                nums[k] = temp[j];
                j++;
            &#125; else if (j == right + 1) &#123;
                nums[k] = temp[i];
                i++;
            &#125; else if (temp[i] &lt;= temp[j]) &#123;
                // 注意写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前）
                nums[k] = temp[i];
                i++;
            &#125; else &#123;
                // temp[i] &gt; temp[j]
                nums[k] = temp[j];
                j++;
            &#125;
        &#125;
    &#125;
&#125;

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="java">import java.util.Random;

public class Solution &#123;

    // 快速排序 1：基本快速排序

    /**
     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序
     */
    private static final int INSERTION_SORT_THRESHOLD = 7;

    private static final Random RANDOM = new Random();


    public int[] sortArray(int[] nums) &#123;
        int len = nums.length;
        quickSort(nums, 0, len - 1);
        return nums;
    &#125;

    private void quickSort(int[] nums, int left, int right) &#123;
        // 小区间使用插入排序
        if (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;
            insertionSort(nums, left, right);
            return;
        &#125;

        int pIndex = partition(nums, left, right);
        quickSort(nums, left, pIndex - 1);
        quickSort(nums, pIndex + 1, right);
    &#125;

    /**
     * 对数组 nums 的子区间 [left, right] 使用插入排序
     *
     * @param nums  给定数组
     * @param left  左边界，能取到
     * @param right 右边界，能取到
     */
    private void insertionSort(int[] nums, int left, int right) &#123;
        for (int i = left + 1; i &lt;= right; i++) &#123;
            int temp = nums[i];
            int j = i;
            while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) &#123;
                nums[j] = nums[j - 1];
                j--;
            &#125;
            nums[j] = temp;
        &#125;
    &#125;

    private int partition(int[] nums, int left, int right) &#123;
        int randomIndex = RANDOM.nextInt(right - left + 1) + left;
        swap(nums, left, randomIndex);

        // 基准值
        int pivot = nums[left];
        int lt = left;
        // 循环不变量：
        // all in [left + 1, lt] &lt; pivot
        // all in [lt + 1, i) &gt;= pivot
        for (int i = left + 1; i &lt;= right; i++) &#123;
            if (nums[i] &lt; pivot) &#123;
                lt++;
                swap(nums, i, lt);
            &#125;
        &#125;
        swap(nums, left, lt);
        return lt;
    &#125;

    private void swap(int[] nums, int index1, int index2) &#123;
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    &#125;
&#125;

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>
<pre><code class="java">import java.util.Random;

public class Solution &#123;

    // 快速排序 2：双指针（指针对撞）快速排序

    /**
     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序
     */
    private static final int INSERTION_SORT_THRESHOLD = 7;

    private static final Random RANDOM = new Random();

    public int[] sortArray(int[] nums) &#123;
        int len = nums.length;
        quickSort(nums, 0, len - 1);
        return nums;
    &#125;

    private void quickSort(int[] nums, int left, int right) &#123;
        // 小区间使用插入排序
        if (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;
            insertionSort(nums, left, right);
            return;
        &#125;

        int pIndex = partition(nums, left, right);
        quickSort(nums, left, pIndex - 1);
        quickSort(nums, pIndex + 1, right);
    &#125;

    /**
     * 对数组 nums 的子区间 [left, right] 使用插入排序
     *
     * @param nums  给定数组
     * @param left  左边界，能取到
     * @param right 右边界，能取到
     */
    private void insertionSort(int[] nums, int left, int right) &#123;
        for (int i = left + 1; i &lt;= right; i++) &#123;
            int temp = nums[i];
            int j = i;
            while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) &#123;
                nums[j] = nums[j - 1];
                j--;
            &#125;
            nums[j] = temp;
        &#125;
    &#125;

    private int partition(int[] nums, int left, int right) &#123;
        int randomIndex = left + RANDOM.nextInt(right - left + 1);
        swap(nums, randomIndex, left);

        int pivot = nums[left];
        int lt = left + 1;
        int gt = right;

        // 循环不变量：
        // all in [left + 1, lt) &lt;= pivot
        // all in (gt, right] &gt;= pivot
        while (true) &#123;
            while (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) &#123;
                lt++;
            &#125;

            while (gt &gt; left &amp;&amp; nums[gt] &gt; pivot) &#123;
                gt--;
            &#125;

            if (lt &gt;= gt) &#123;
                break;
            &#125;

            // 细节：相等的元素通过交换，等概率分到数组的两边
            swap(nums, lt, gt);
            lt++;
            gt--;
        &#125;
        swap(nums, left, gt);
        return gt;
    &#125;

    private void swap(int[] nums, int index1, int index2) &#123;
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    &#125;
&#125;

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>
<pre><code class="java">import java.util.Random;

public class Solution &#123;

    // 快速排序 3：三指针快速排序

    /**
     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序
     */
    private static final int INSERTION_SORT_THRESHOLD = 7;

    private static final Random RANDOM = new Random();

    public int[] sortArray(int[] nums) &#123;
        int len = nums.length;
        quickSort(nums, 0, len - 1);
        return nums;
    &#125;

    private void quickSort(int[] nums, int left, int right) &#123;
        // 小区间使用插入排序
        if (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;
            insertionSort(nums, left, right);
            return;
        &#125;

        int randomIndex = left + RANDOM.nextInt(right - left + 1);
        swap(nums, randomIndex, left);

        // 循环不变量：
        // all in [left + 1, lt] &lt; pivot
        // all in [lt + 1, i) = pivot
        // all in [gt, right] &gt; pivot
        int pivot = nums[left];
        int lt = left;
        int gt = right + 1;

        int i = left + 1;
        while (i &lt; gt) &#123;
            if (nums[i] &lt; pivot) &#123;
                lt++;
                swap(nums, i, lt);
                i++;
            &#125; else if (nums[i] == pivot) &#123;
                i++;
            &#125; else &#123;
                gt--;
                swap(nums, i, gt);
            &#125;
        &#125;
        swap(nums, left, lt);
        // 注意这里，大大减少了两侧分治的区间
        quickSort(nums, left, lt - 1);
        quickSort(nums, gt, right);
    &#125;

    /**
     * 对数组 nums 的子区间 [left, right] 使用插入排序
     *
     * @param nums  给定数组
     * @param left  左边界，能取到
     * @param right 右边界，能取到
     */
    private void insertionSort(int[] nums, int left, int right) &#123;
        for (int i = left + 1; i &lt;= right; i++) &#123;
            int temp = nums[i];
            int j = i;
            while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) &#123;
                nums[j] = nums[j - 1];
                j--;
            &#125;
            nums[j] = temp;
        &#125;
    &#125;

    private void swap(int[] nums, int index1, int index2) &#123;
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    &#125;
&#125;

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><pre><code class="java">public class Solution &#123;

    public int[] sortArray(int[] nums) &#123;
        int len = nums.length;
        // 将数组整理成堆
        heapify(nums);

        // 循环不变量：区间 [0, i] 堆有序
        for (int i = len - 1; i &gt;= 1; ) &#123;
            // 把堆顶元素（当前最大）交换到数组末尾
            swap(nums, 0, i);
            // 逐步减少堆有序的部分
            i--;
            // 下标 0 位置下沉操作，使得区间 [0, i] 堆有序
            siftDown(nums, 0, i);
        &#125;
        return nums;
    &#125;

    /**
     * 将数组整理成堆（堆有序）
     *
     * @param nums
     */
    private void heapify(int[] nums) &#123;
        int len = nums.length;
        // 只需要从 i = (len - 1) / 2 这个位置开始逐层下移
        for (int i = (len - 1) / 2; i &gt;= 0; i--) &#123;
            siftDown(nums, i, len - 1);
        &#125;
    &#125;

    /**
     * @param nums
     * @param k    当前下沉元素的下标
     * @param end  [0, end] 是 nums 的有效部分
     */
    private void siftDown(int[] nums, int k, int end) &#123;
        while (2 * k + 1 &lt;= end) &#123;
            int j = 2 * k + 1;
            if (j + 1 &lt;= end &amp;&amp; nums[j + 1] &gt; nums[j]) &#123;
                j++;
            &#125;
            if (nums[j] &gt; nums[k]) &#123;
                swap(nums, j, k);
            &#125; else &#123;
                break;
            &#125;
            k = j;
        &#125;
    &#125;

    private void swap(int[] nums, int index1, int index2) &#123;
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    &#125;
&#125;

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%87%8D%E6%96%B0%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/" data-id="ckidz590t0009loux16fu5hc6" class="article-share-link" data-share="baidu" data-title="排序算法之重新总结归纳">分享到</a>
      

      
        <a href="http://example.com/2020/11/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%87%8D%E6%96%B0%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201105" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201105/" class="article-date">
  <time datetime="2020-11-04T16:00:00.000Z" itemprop="datePublished">2020-11-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201105/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-05"><a href="#每天一条算法题2020-11-05" class="headerlink" title="每天一条算法题2020/11/05"></a>每天一条算法题2020/11/05</h3><p>给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。</p>
<p>注意：1 ≤ k ≤ n ≤ 109。</p>
<p>示例 :</p>
<p>输入:<br>n: 13   k: 2</p>
<p>输出:<br>10</p>
<p>解释:<br>字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order">https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">/*其实这个字典数是“十叉树”，就是每个节点可以有十个孩子。
但是由于n大小的限制，构成的并不是一个满十叉树。比如示例中1只有[10,11,12,13]四个孩子。
那么这就是先序遍历十叉树的问题，难点就变成了如何计算出每个节点的子节点的个数，
我们不停的用k减去子节点的个数，当k减到0的时候，当前位置的数字即为所求。*/

class Solution &#123;
    public int findKthNumber(int n, int k) &#123;
        int cur = 1;
        --k;

        while (k &gt; 0) &#123; //此解答中k为0时表示已经到达了目标节点
            long step = 0, first = cur, last = cur + 1;
            //这里的代码是为了查找当前树的字典序的数字个数，因为存在父节点就是要寻找的目标数字的情况，所以要小于等于&lt;=
            while (first &lt;= n) &#123;
                step += Math.min(last, (long) n + 1) - first;//不能超过n的值，并不是所有节点都有十个子节点
                first *= 10;
                last *= 10;
            &#125;
            //如果数字个数大于k值，则证明寻找的数字在此树中
            if (step &gt; k) &#123;
                --k; //减去父节点的个数
                cur *= 10; //继续查找该节点的字典序
            &#125;
            //step &lt;= k 时, 说明寻找的数字不在该树中
            if (step &lt;= k) &#123;
                k -= step;
                ++cur;
            &#125;
        &#125;
        return cur;

    &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201105/" data-id="ckidz590w000hlouxg7zpf4t9" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201105/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201104" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201104/" class="article-date">
  <time datetime="2020-11-03T16:00:00.000Z" itemprop="datePublished">2020-11-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201104/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-04"><a href="#每天一条算法题2020-11-04" class="headerlink" title="每天一条算法题2020/11/04"></a>每天一条算法题2020/11/04</h3><p>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</p>
<p>选择二叉树中 任意 节点和一个方向（左或者右）。<br>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。<br>改变前进方向：左变右或者右变左。<br>重复第二步和第三步，直到你在树中无法继续移动。<br>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。</p>
<p>请你返回给定树中最长 交错路径 的长度。</p>
<p>示例 1：</p>
<p>输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]<br>输出：3<br>解释：蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。<br>示例 2：</p>
<p>输入：root = [1,1,1,null,1,null,null,1,1,null,1]<br>输出：4<br>解释：蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。<br>示例 3：</p>
<p>输入：root = [1]<br>输出：0</p>
<p>提示：</p>
<p>每棵树最多有 50000 个节点。<br>每个节点的值在 [1, 100] 之间。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree">https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">//效率最高
/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val = x; &#125;
 * &#125;
 */
class Solution &#123;
    int max = 0;
    public int longestZigZag(TreeNode root) &#123;
        helper(root, false);
        return max;
    &#125;
    public int helper(TreeNode root, boolean isLeft) &#123;
        if(root == null) return 0;
        int r = helper(root.right, false);
        int l = helper(root.left, true);
        int big = r &gt; l ? r : l;
        max = max &gt; big ? max : big;
        if(isLeft) &#123;
            return r + 1;
        &#125;else &#123;
            return l + 1;
        &#125;
    &#125;
&#125;</code></pre>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val = x; &#125;
 * &#125;
 */
class Solution &#123;
    int ans;
    public int longestZigZag(TreeNode root) &#123;
        if(root == null) return 0;
        ans = 0;
        helper(root, true, 0);
        helper(root, false, 0);
        return ans;
    &#125;

    public void helper(TreeNode root, boolean dir, int len) &#123;
        ans = Math.max(ans, len);

        if(dir) &#123;
            if(root.left != null) &#123;
                helper(root.left, false, len + 1);
            &#125;
            if(root.right != null) &#123;
                helper(root.right, true, 1);
            &#125;
        &#125;else &#123;
            if(root.right != null) &#123;
                helper(root.right, true, len + 1);
            &#125;
            if(root.left != null) &#123;
                helper(root.left, false, 1);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201104/" data-id="ckidz590v000flouxdxg9dqnz" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201104/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201103" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201103/" class="article-date">
  <time datetime="2020-11-02T16:00:00.000Z" itemprop="datePublished">2020-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201103/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-03"><a href="#每天一条算法题2020-11-03" class="headerlink" title="每天一条算法题2020/11/03"></a>每天一条算法题2020/11/03</h3><p>给定一个整数 n, 返回从 1 到 n 的字典顺序。</p>
<p>例如，</p>
<p>给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p>
<p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lexicographical-numbers">https://leetcode-cn.com/problems/lexicographical-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; lexicalOrder(int n) &#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 1; i &lt; 10; i++) &#123;
            dfs(n, i, list);
        &#125;
        return list;
    &#125;

    private void dfs(int n, int target, List&lt;Integer&gt; list) &#123;
        if (target &gt; n) return;
        list.add(target);
        target *= 10;
        for (int i = 0; i &lt; 10; i++) &#123;
            dfs(n, target + i, list);
        &#125;
    &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201103/" data-id="ckidz590u000bloux6sfpgbqi" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201103/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-每天一条算法题20201102" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201102/" class="article-date">
  <time datetime="2020-11-01T16:00:00.000Z" itemprop="datePublished">2020-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201102/">每天一条算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="每天一条算法题2020-11-02"><a href="#每天一条算法题2020-11-02" class="headerlink" title="每天一条算法题2020/11/02"></a>每天一条算法题2020/11/02</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">/** 使用滑动窗口在字符串上滑动*/
    public int lengthOfLongestSubstring(String s) &#123;
     // 记录当前字符前一次出现的位置
     int[] lastIndex = new int[128];
     for(int i = 0; i &lt; lastIndex.length; i++) &#123;
         lastIndex[i] = -1;
     &#125;

     // 滑动窗口起点
     int start = 0;
     // 滑动窗口大小
     int size = 0;
     // 窗口滑动
     for(int i = 0;i &lt; s.length(); i++) &#123;
         int index = s.charAt(i); 
         start = (start &gt; lastIndex[index] + 1) ? start : lastIndex[index] + 1;
         size = (size &gt; i - start + 1) ? size : i - start + 1;  
         lastIndex[index] = i;
     &#125;

     return size;
    &#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/11/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201102/" data-id="ckidz590q0005louxgne41e98" class="article-share-link" data-share="baidu" data-title="每天一条算法题">分享到</a>
      

      
        <a href="http://example.com/2020/11/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201102/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9D%91/">坑</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9D%91/MySQL/">MySQL</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/">Spring框架解析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">10</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap/">HashMap</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashSet/">HashSet</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Hashtable/">Hashtable</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Stack/">Stack</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Vector/">Vector</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">计算机网络基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashSet/" rel="tag">HashSet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashtable/" rel="tag">Hashtable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" rel="tag">Spring框架解析</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack/" rel="tag">Stack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vector/" rel="tag">Vector</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9D%91/" rel="tag">坑</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="tag">计算机网络基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/HashSet/" style="font-size: 10px;">HashSet</a> <a href="/tags/Hashtable/" style="font-size: 10px;">Hashtable</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Spring%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">Spring框架解析</a> <a href="/tags/Stack/" style="font-size: 10px;">Stack</a> <a href="/tags/Vector/" style="font-size: 10px;">Vector</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">单例模式</a> <a href="/tags/%E5%9D%91/" style="font-size: 10px;">坑</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">学习笔记</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">排序算法</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 16.67px;">源码分析</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">计算机网络基础</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201110/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201109/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201108/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201107/">每天一条算法题</a>
          </li>
        
          <li>
            <a href="/2020/11/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E6%9D%A1%E7%AE%97%E6%B3%95%E9%A2%9820201106/">每天一条算法题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://arvinxiang.com" target="_blank">主题作者</a>
          </li>
        
          <li>
            <a href="http://reqianduan.com" target="_blank">热前端</a>
          </li>
        
          <li>
            <a href="http://yuancheng.work" target="_blank">远程.work</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Franklin<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>





<script src="/js/script.js"></script>


</div>
</body>
</html>
